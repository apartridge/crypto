#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Crypto in D
\end_layout

\begin_layout Author
Lars Kirkholt Melhus and Stian Pedersen
\end_layout

\begin_layout Abstract
In this paper we describe our experiences with implementing some common
 cryptographic primitives in the D programming language.
 The result can be found at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://github.com/apartridge/crypto
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Many of the more popular programming languages support cryptographic algorithms
 like symmetric encryption, hashing and public key cryptography as part
 of a standard library.
 It has been suggested to add native crypto implementation in the D standard
 library (Phobos), but so far this has not been done.
 In particular, there seems to be no standard implementation of asymmetric
 encryption like RSA in D.
 There are however, third party libraries for basic cryptography, but they
 are either incomplete or not under active development.
\end_layout

\begin_layout Standard
Our goal has been to implement fast cryptographic primitives in pure D,
 including new algorithms like RSA.
 
\end_layout

\begin_layout Subsection
The D programming language
\end_layout

\begin_layout Standard
Syntactically D derives much from C and C++, and should be very easy to
 read and understand for people used to C-style languages.
 Below is a fragment of code written in D, borrowed from the official homepage
 of the language 
\begin_inset CommandInset citation
LatexCommand cite
key "Dlang"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

import std.stdio;
\end_layout

\begin_layout Plain Layout

void main() {
\end_layout

\begin_layout Plain Layout

    ulong lines = 0;
\end_layout

\begin_layout Plain Layout

    double sumLength = 0;
\end_layout

\begin_layout Plain Layout

    foreach (line; stdin.byLine()) {
\end_layout

\begin_layout Plain Layout

        ++lines;
\end_layout

\begin_layout Plain Layout

        sumLength += line.length;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    writeln("Average line length: ", lines ? sumLength / lines : 0);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example code in D.
 Computes average line length for standard input.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
So why yet another language you might ask? The creators of D argue that
 the language fills a need for a powerful modern systems programming language.
 It combines features such as managed (garbage collected) code like C# and
 Java, yet it compiles to efficient native machine code like C or C++.
 Native code is especially important in cryptography, as the algorithms
 needs to be as fast as possible.
 At the same time, the elevated level of abstraction and high-level features
 compared to C makes D an interesting target for implementation.
 
\end_layout

\begin_layout Quote
D is a language with C-like syntax and static typing.
 It pragmatically combines efficiency, control, and modeling power, with
 safety and programmer productivity.
\end_layout

\begin_layout Quote
dlang.org
\end_layout

\begin_layout Standard
The current incarnation is known as D2, and its standard library is called
 Phobos.
 For more information about D, we refer to the official homepage 
\begin_inset CommandInset citation
LatexCommand cite
key "Dlang"

\end_inset

.
 
\end_layout

\begin_layout Standard
Below we will highlight some of the interesting features of the language,
 and describe how they impacted our implementation.
 
\end_layout

\begin_layout Paragraph*
Unit tests
\end_layout

\begin_layout Standard
Test-driven development is as popular as ever, but few languages has actually
 been designed with this paradigm in mind from the very beginning.
 D supports the 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

unittest
\end_layout

\end_inset

 keyword, which declares a block statement that is supposed to run (and
 hopefully pass without assertion errors) every time the program is compiled
 and run.
 
\end_layout

\begin_layout Standard
From our experiences with similar-sized projects in other programming languages,
 tests are almost always ignored.
 In the case of D, we found that the seamless integration of unit tests
 actually made us write them.
 Including tests for the core functionality has some benefits; 
\end_layout

\begin_layout Itemize
Tests helps weeding out errors early on.
 The time you save debugging a function by catching errors with a simple
 test will make it worth it writing the test in the first place.
 
\end_layout

\begin_layout Itemize
Integrated unittests are supposed to help with documenting the code.
 They can be seen used extensively in the D standard library 
\begin_inset CommandInset citation
LatexCommand cite
key "Phobos"

\end_inset

.
\end_layout

\begin_layout Standard
In release modes, the compiler ignores all unittest code, so there is no
 overhead in including them.
 We use unittests extensively, for instance in testing the results of the
 AES and hash functions.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

unittest
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    assert(subWord(0x73744765) == 0x8f92a04d);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Example of a unit test in the AES module.
 As a separate statement below the function body we include a little snippet
 of code to verify everything works as expected.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Integrated assembly code
\end_layout

\begin_layout Standard
D has a very cool feature for integrating assembly code directly in the
 language.
 In C and C++, different compilers have different solutions to mixing assembly
 together with the program code.
 To make this seamless, D has its own assembler, and assembly code can be
 used by the 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

asm
\end_layout

\end_inset

 keyword.
 This is especially useful for implementing highly optimized algorithms,
 and whenever you want to use very specific instructions.
 
\end_layout

\begin_layout Standard
Recently Intel released their AES-NI 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel"

\end_inset

 instruction set extension for hardware accelerated AES, which would be
 very handy for implementing faster AES.
 Unfortunately, D's assembler does not (yet) support these instructions,
 so we were unable to utilize this in our implementation.
 However, we expect these instructions to be supported eventually, which
 would greatly increase the speed of AES implementations in D.
 
\end_layout

\begin_layout Paragraph*
Generic programming with templates
\end_layout

\begin_layout Standard
Templates is a powerful feature that allows classes or functions to operate
 on generic types, without having to rewrite the function or class for each
 type.
 The classic example is a swap function, which makes sense for most data
 types, not only ints or floats.
 They can also be used for complex compile time evalutations of functions.
 Templates has it's role in C++, but have heavy syntax and often impairs
 compilation times.
 In D, they have much cleaner syntax, making them 
\begin_inset Quotes eld
\end_inset

compile time arguments
\begin_inset Quotes erd
\end_inset

 of sorts.
 In addition, D supports the 
\begin_inset Formula $\mathtt{static}$
\end_inset

 keyword before 
\begin_inset Formula $\mathtt{if}$
\end_inset

, making it a compile time conditional.
 We utilize these features heavily in our library, giving us the ability
 to abstract away details like key length, internal data type or output
 byte length from the algorithms, and specifying that for each incarnation
 (for instance, each variant of the SHA family).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

class Bar(T) {
\end_layout

\begin_layout Plain Layout

    T member;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A templated class in D.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cryptography
\end_layout

\begin_layout Standard
We have looked at three basic cryptographic primitives; block ciphers, hash
 functions and public key cryptography (RSA).
 These are all low-level primitives, which we can use to build high-level
 protocols.
 We provide a brief description of each of them.
 
\end_layout

\begin_layout Paragraph*
Hash functions
\end_layout

\begin_layout Standard
A hash function is a one-way function 
\begin_inset Formula $f:X\rightarrow M$
\end_inset

 that maps elements in some domain 
\begin_inset Formula $X$
\end_inset

 to a (usually smaller) range 
\begin_inset Formula $M$
\end_inset

.
 An example is the hash function MD5, which maps bits of arbitrary length
 to bitstrings of length 
\begin_inset Formula $128$
\end_inset

; 
\begin_inset Formula $f_{md5}:\left\{ 0,1\right\} ^{*}\rightarrow\left\{ 0,1\right\} ^{128}$
\end_inset

.
 
\end_layout

\begin_layout Paragraph*
Block ciphers
\end_layout

\begin_layout Standard
Informally, a block cipher is a function that given a key can transform
 messages (plaintext) to ciphertext, or ciphertext back to messages.
 Usually we define the domain to be binary numbers.
 With message length 
\begin_inset Formula $l$
\end_inset

 (in bits), and some key 
\begin_inset Formula $K$
\end_inset

 we can denote a block cipher as a function 
\begin_inset Formula $E_{K}:\left\{ 0,1\right\} ^{l}\rightarrow\left\{ 0,1\right\} ^{l}$
\end_inset

.
 Unlike hash functions, there will always be an inverse 
\begin_inset Formula $E_{K}^{-1}:\left\{ 0,1\right\} ^{l}\rightarrow\left\{ 0,1\right\} ^{l}$
\end_inset

.
 
\begin_inset Formula $E$
\end_inset

 is a permutation for every key 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard
Examples of block ciphers include DES, AES, RC5 and Blowfish.
\end_layout

\begin_layout Paragraph*
Public key cryptography
\end_layout

\begin_layout Standard
In these schemes there are two keys involved in encryption and decryption:
 a public key and a private key.
 The idea is to have a function 
\begin_inset Formula $f\left(x\right)$
\end_inset

 constructed using some public key, with the property that getting back
 
\begin_inset Formula $x$
\end_inset

 (the message) is hard without some secret (private key).
 
\end_layout

\begin_layout Standard
As an example of how this could work, consider Alice wanting to send a message
 to Bob.
 Alice needs to aquire Bob's public key, and use that to compute the function
 
\begin_inset Formula $f\left(x\right)$
\end_inset

.
 Now, the function 
\begin_inset Formula $f$
\end_inset


\begin_inset Formula $^{-1}\left(f\left(x\right)\right)$
\end_inset

 can only be computed by Bob, who has the private key.
\end_layout

\begin_layout Standard
There are multiple ways of implementing the function 
\begin_inset Formula $f$
\end_inset

, RSA being one concrete scheme.
 
\end_layout

\begin_layout Section
Implementing AES
\end_layout

\begin_layout Standard
Advanced Encryption Standard (AES) is a widely used block cipher, also known
 as Rijndael after its developers Joan Daemen and Vincent Rijmen.
 It was selected as the successor to Data Encryption Standard (DES), and
 standardized by the National Insitute of Standards and Technology with
 
\begin_inset CommandInset citation
LatexCommand cite
key "FIPS197"

\end_inset

 in 2001.
 AES supports message lengths of 128 bits, and key sizes of 128, 192 or
 256 bits.
 We will refer to them as AES-128, AES-192 and AES-256.
 
\end_layout

\begin_layout Standard
Because of its popularity, AES is naturally one of the most important implementa
tions in any cryptographic library.
 Unfortunately, implementing it like it is presented in the standard is
 way too slow for real world applications.
 A naive implementation in D gave a throughput of about 1MB/s on an Intel
 Core 2 Duo running at 2.4GHz.
 As a reference, benchmarking AES in OpenSSL running 
\begin_inset Quotes eld
\end_inset

openssl speed aes-128-cbc
\begin_inset Quotes erd
\end_inset

 yields a throughput of about 80MB/s.
 (NB: On hardware without AES-NI support).
\end_layout

\begin_layout Standard
To see how we can do better, let's look at what happens during a round of
 AES encryption.
 
\end_layout

\begin_layout Subsection
Description of the cipher (encryption)
\end_layout

\begin_layout Standard
The standard decribes the algorithm's internal operation as a series of
 mutations on a two-dimensional array of bytes called the 
\emph on
state
\emph default
.
 The bytes are numbered 
\begin_inset Formula $s_{0,0}$
\end_inset

, 
\begin_inset Formula $s_{1,0}$
\end_inset

, ..
 
\begin_inset Formula $s_{3,3}$
\end_inset

.
 
\begin_inset Formula 
\[
\left[\begin{array}{cccc}
s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3}\\
s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3}\\
s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3}\\
s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
On 32-bit processors, the state can be thought of as an array of four 32-bit
 words, where each word represents a column of the state.
 The first word address points to 
\begin_inset Formula $s_{0,0}$
\end_inset

.
\end_layout

\begin_layout Standard
The same series of state transformations are performed over and over in
 some number of rounds, Nr (10 for AES-128, 12 for AES-192 and 14 for AES-256).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Cipher(byte in[4*4], byte out[4*4], word w[4*(Nr+1)])
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

    byte state[4,Nb]
\end_layout

\begin_layout Plain Layout

    state = in
\end_layout

\begin_layout Plain Layout

    AddRoundKey(state, w[0, 3])
\end_layout

\begin_layout Plain Layout

    for round = 1 step 1 to Nr–1
\end_layout

\begin_layout Plain Layout

        SubBytes(state)
\end_layout

\begin_layout Plain Layout

        ShiftRows(state)
\end_layout

\begin_layout Plain Layout

        MixColumns(state)
\end_layout

\begin_layout Plain Layout

        AddRoundKey(state, w[round*4, (round+1)*4-1])
\end_layout

\begin_layout Plain Layout

    end for
\end_layout

\begin_layout Plain Layout

    SubBytes(state)
\end_layout

\begin_layout Plain Layout

    ShiftRows(state)
\end_layout

\begin_layout Plain Layout

    AddRoundKey(state, w[4*4, (Nr+1)*4-1])
\end_layout

\begin_layout Plain Layout

    out = state
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Pseudo code for AES encryption, as presented in FIPS197
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each step of the algorithm can be expressed in terms of operations on words
 (column vectors in the state).
 Let 
\begin_inset Formula $c\in\left\{ 0,1,2,3\right\} $
\end_inset

 index each column of the state.
 Below we describe each transformation as matrix operations, where column
 
\begin_inset Formula $c$
\end_inset

 of the new state 
\begin_inset Formula $s^{\prime}$
\end_inset

 is given as a function of the current state 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Paragraph*
SubBytes
\end_layout

\begin_layout Standard
Substitute each byte of the state according to a substitution table (sbox).
 Let 
\begin_inset Formula $SB[x]$
\end_inset

 be the substitution of byte 
\begin_inset Formula $x$
\end_inset

 according to the sbox.
 For all words 
\begin_inset Formula $c\in\left\{ 0,1,2,3\right\} $
\end_inset

 we have 
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=\left[\begin{array}{c}
SB[s_{0,c}]\\
SB[s_{1,c}]\\
SB[s_{2,c}]\\
SB[s_{3,c}]
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Paragraph*
ShiftRows
\end_layout

\begin_layout Standard
Rotate row 
\begin_inset Formula $i$
\end_inset

 of the current state by 
\begin_inset Formula $i$
\end_inset

 bytes.
 The following transformation yields column 
\begin_inset Formula $c$
\end_inset

 for the new state 
\begin_inset Formula $s^{\prime}$
\end_inset

.
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=\left[\begin{array}{c}
s_{0,c}\\
s_{1,c+1\bmod4}\\
s_{2,c+2\bmod4}\\
s_{3,c+3\bmod4}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Paragraph*
MixColumns
\end_layout

\begin_layout Standard
Each column 
\begin_inset Formula $c$
\end_inset

 of 
\begin_inset Formula $s$
\end_inset

 is multiplied with a fixed matrix to get the corresponding column 
\begin_inset Formula $c$
\end_inset

 of 
\begin_inset Formula $s^{\prime}$
\end_inset

.
 The arithmetic operations are finite field operations in GF(256) 
\begin_inset CommandInset citation
LatexCommand cite
key "FIPS197"

\end_inset

.
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=\left[\begin{array}{cccc}
02 & 03 & 01 & 01\\
01 & 02 & 03 & 01\\
01 & 01 & 02 & 03\\
03 & 01 & 01 & 02
\end{array}\right]\left[\begin{array}{c}
s_{0,c}\\
s_{1,c}\\
s_{2,c}\\
s_{3,c}
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Paragraph*
AddRoundKey
\end_layout

\begin_layout Standard
Simply xor each byte of the current round key with the state.
 Let 
\begin_inset Formula $k_{i,c}$
\end_inset

 denote byte 
\begin_inset Formula $i$
\end_inset

 of column 
\begin_inset Formula $c$
\end_inset

 in the key used for 
\begin_inset Formula $round\in\left\{ 1,\,...,\, Nr\right\} $
\end_inset

, similar to the state array numbering.
 A key expansion algorithm is used to generate a separate key for each round
 of encryption based on the original key.
 See 
\begin_inset CommandInset citation
LatexCommand cite
key "FIPS197"

\end_inset

 for details.
 
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=\left[\begin{array}{c}
s_{0,c}\\
s_{1,c}\\
s_{2,c}\\
s_{3,c}
\end{array}\right]\oplus\left[\begin{array}{c}
k_{0,c}\\
k_{1,c}\\
k_{2,c}\\
k_{3,c}
\end{array}\right]_{round}
\]

\end_inset


\end_layout

\begin_layout Subsection
Efficient implementation using tables
\end_layout

\begin_layout Standard
We can optimize the cipher by combining each of the steps to one.
 In column matrix notation, SubBytes, ShiftRows, MixColumns and AddRoundKey
 combined to one gives a single expression for each column 
\begin_inset Formula $c$
\end_inset

.
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=\left[\begin{array}{cccc}
02 & 03 & 01 & 01\\
01 & 02 & 03 & 01\\
01 & 01 & 02 & 03\\
03 & 01 & 01 & 02
\end{array}\right]\left[\begin{array}{c}
SB[s_{0,c}]\\
SB[s_{1,c+1\bmod4}]\\
SB[s_{2,c+2\bmod4}]\\
SB[s_{3,c+3\bmod4}]
\end{array}\right]\oplus\left[\begin{array}{c}
k_{0,c}\\
k_{1,c}\\
k_{2,c}\\
k_{3,c}
\end{array}\right]_{round}
\]

\end_inset


\end_layout

\begin_layout Standard
We can split this into five components, using the fact that addition under
 GF(256) is xor.
 
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=SB[s_{0,c}]\left[\begin{array}{c}
02\\
01\\
01\\
03
\end{array}\right]\oplus SB[s_{1,c+1\bmod4}]\left[\begin{array}{c}
03\\
02\\
01\\
01
\end{array}\right]\oplus SB[s_{2,c+2\bmod4}]\left[\begin{array}{c}
01\\
03\\
02\\
01
\end{array}\right]\oplus SB[s_{3,c+3\bmod4}]\left[\begin{array}{c}
01\\
01\\
03\\
02
\end{array}\right]\oplus\left[\begin{array}{c}
k_{0,c}\\
k_{1,c}\\
k_{2,c}\\
k_{3,c}
\end{array}\right]_{round}
\]

\end_inset


\end_layout

\begin_layout Standard
Each of the first four components are 32-bit words as a function of byte
 value, that for a given column 
\begin_inset Formula $c$
\end_inset

 is 
\begin_inset Formula $s_{0,c}$
\end_inset

, 
\begin_inset Formula $s_{1,c+1\bmod4}$
\end_inset

, 
\begin_inset Formula $s_{2,c+2\bmod4}$
\end_inset

 and 
\begin_inset Formula $s_{3,c+3\bmod4}$
\end_inset

.
 Each byte can have only 
\begin_inset Formula $256$
\end_inset

 different values, which means that we can precompute and store the result
 of each operation as an array of words indexed by byte value.
 Each table will contain 
\begin_inset Formula $256$
\end_inset

 words, so the size will be 
\begin_inset Formula $4\times256=1KB$
\end_inset

.
 Let 
\begin_inset Formula $\bullet$
\end_inset

 denote finite field multiplication, and define tables 
\begin_inset Formula $T_{1}$
\end_inset

 to 
\begin_inset Formula $T_{4}$
\end_inset

 indexed by byte 
\begin_inset Formula $x\in\left\{ 0,1,\,...,\,255\right\} $
\end_inset

.
 
\begin_inset Formula 
\[
T_{1}[x]=\left[\begin{array}{c}
02\bullet SB[x]\\
01\bullet SB[x]\\
01\bullet SB[x]\\
03\bullet SB[x]
\end{array}\right],\, T_{2}[x]=\left[\begin{array}{c}
03\bullet SB[x]\\
02\bullet SB[x]\\
01\bullet SB[x]\\
01\bullet SB[x]
\end{array}\right],\, T_{3}[x]=\left[\begin{array}{c}
01\bullet SB[x]\\
03\bullet SB[x]\\
02\bullet SB[x]\\
01\bullet SB[x]
\end{array}\right],\, T_{4}[x]=\left[\begin{array}{c}
01\bullet SB[x]\\
01\bullet SB[x]\\
03\bullet SB[x]\\
02\bullet SB[x]
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, we can write a round of encryption as a series of lookups and xors
 defined for each state column 
\begin_inset Formula $c\in\left\{ 0,1,2,3\right\} $
\end_inset

.
\begin_inset Formula 
\[
\left[\begin{array}{c}
s_{0,c}^{\prime}\\
s_{1,c}^{\prime}\\
s_{2,c}^{\prime}\\
s_{3,c}^{\prime}
\end{array}\right]=T_{1}[s_{0,c}]\oplus T_{2}[s_{1,c+1\bmod4}]\oplus T_{3}[s_{2,c+2\bmod4}]\oplus T_{4}[s_{1,c+3\bmod4}]\oplus\left[\begin{array}{c}
k_{0,c}\\
k_{1,c}\\
k_{2,c}\\
k_{3,c}
\end{array}\right]_{round}
\]

\end_inset


\end_layout

\begin_layout Standard
This approach combines all the steps in one round; SubBytes, ShiftRows,
 MixColumns and AddRoundKey.
 Note that the very last round (Algorithm 5) does not contain the MixColumns
 step, so we can not use the same lookup method for this step.
 
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
Using the optimized table implementation we achieved a throughput of about
 30MB/s, a huge improvement over the straight-forward implementation.
 This is still not as fast as highly optimized C/assembly implementations
 like OpenSSL, however we do believe that the gap can be reduced by further
 optimization like more loop unrolling, inline assembly etc.
\end_layout

\begin_layout Section
Implementing SHA
\end_layout

\begin_layout Standard
Our library contains hash functions SHA1 and SHA2 (SHA224, SHA256, SHA384
 and SHA512).
 These are implemented using a Merkle-Damgård base class which handles putting
 data into the hash function, required internal buffering and constructs
 common to MD.
 A common Hash base class defines the interface and includes convinience
 functions and templates for its use.
 The implementations follow the outline and uses the nomenclature as defined
 by the SHA standard.
 
\begin_inset CommandInset citation
LatexCommand cite
key "SHS"

\end_inset


\end_layout

\begin_layout Standard
We were interested in comparing the speed of our SHA implementation with
 a current widely employed implementation, namely the OpenSSL version.
 We created a simple benchmark test.
 In each round, we take the hash of 
\begin_inset Quotes eld
\end_inset

The quick brown fox jumps over the lazy dog
\begin_inset Quotes erd
\end_inset

 as well as a 446 character 
\begin_inset Quotes eld
\end_inset

Lorem Ipsum
\begin_inset Quotes erd
\end_inset

 string.
 We include the longer string to stress test the buffering capabilities
 of the implementations.
 All hash functions return binary results to avoid overhead of convert to
 strings.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D-Crypto
\begin_inset Formula $*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D-Crypto
\begin_inset Formula $\dagger$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenSSL 1.0.0e 
\begin_inset Formula $\ddagger$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100 000 iterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.886 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.810 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.237 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.744 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 000 000 iterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.212 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.926 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.345 s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.925 s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Speeds mesaured on Intel i7 720QM.
 
\begin_inset Formula $*$
\end_inset

 Compiled with DMD 2.058 and optimization flags -O -inline -release.
 
\begin_inset Formula $\dagger$
\end_inset

 Compiled with DMD 2.058 and flags -O -noboundscheck -inline -release (removed
 bounds check).
 
\begin_inset Formula $\ddagger$
\end_inset

 Compiled with Visual C++ v10 in Release configuration with /02 (
\begin_inset Quotes eld
\end_inset

Maximize Speed
\begin_inset Quotes erd
\end_inset

) and 
\begin_inset Quotes eld
\end_inset

Favouring Faster Code
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results show that our version is about 2.5 times slower than OpenSSL,
 and somewhat slower than Java.
 We have compared our implementation with OpenSSL.
 Their current implementation depends heavily on macros, unrolling the rounds
 loop and chaining round variables smarter than we do.
 It is obvious that all the time is spent inside round loops and these optimizat
ions have an effect.
 Before we could give fair judgement on the speed of C versus D code, our
 version would need optimizations.
\end_layout

\begin_layout Standard
It is also possible, by rewriting some of the equations, to implement parts
 of it using SIMD vector instructions, supported by newer processors.
 However, we have not pursued these optimizations further in this project.
\end_layout

\begin_layout Section
Implementing RSA
\end_layout

\begin_layout Standard
Our library contains RSA Key Generation and encryption/decryption features.
 We use the Phobos BigInt library.
 However, we found it to be incomplete for our use.
 It was missing a modular exponentiation method, and utility functions like
 converting from/to native D byte arrays.
 In addition, we needed random BigInts.
 We forked BigInt and added this functionality ourselves.
\end_layout

\begin_layout Standard
The RSA Key Generation contains all functionality necessary to create new
 RSA keys.
 For prime verification, first we check the number modulo the lowest primes.
 We then verify the candidates using the Miller-Rabin primality test.
 At each iteration, fetch a random number 
\begin_inset Formula $a$
\end_inset

.
 A composite number will fail the test for 
\begin_inset Formula $3/4$
\end_inset

 of all 
\begin_inset Formula $a$
\end_inset

's less than the number.
 Our key generation will return a composite number (instead of a prime)
 with a probability of at most 
\begin_inset Formula $\dfrac{1}{4^{N}}$
\end_inset

.
 We have set 
\begin_inset Formula $N=40$
\end_inset

.
\end_layout

\begin_layout Standard
We have implemented a Random generator interface and a simple insecure Random
 Number generator, based on a Mersenne Twister engine, which is a part of
 the D standard library.
 This is only for testing, and could create the same keys if two persons
 run it at the same second.
 For cryptographic use, we would have to implement a much stronger random
 generator and a plentiful resource of entropy.
 We could create a more sophisticated PRNG using a hash function.
 The OpenSSL website has a short article on the construction of such a PRNG.
 
\begin_inset CommandInset citation
LatexCommand cite
key "OpenSSL Rand Documentation"

\end_inset

 In any case, the user of the library would need to 
\begin_inset Quotes eld
\end_inset

plug in
\begin_inset Quotes erd
\end_inset

 some source of entropy.
 It could be a hardware device, a daemon running on the client that captures
 mouse and keyboard actions, etc.
 It is outside the scope of our project and a problem for anyone who would
 want to use any library to create RSA keys themselves.
\end_layout

\begin_layout Standard
The Encryption/Decryption supports both unpadded (insecure) and padded modes,
 using OAEP.
 OAEP was introduced in 
\begin_inset CommandInset citation
LatexCommand cite
key "OAEP"

\end_inset

 and gives RSA powerful security properties.
 We follow the standard defined in PKCS#1 2.1 
\begin_inset CommandInset citation
LatexCommand cite
key "PKCS1 v2.1"

\end_inset

, which differ in the details from the suggested scheme of the original
 paper.
 We use SHA1 within the Mask Generation Function.
 RSAES-OAEP can operate on messages of length up to 
\begin_inset Formula $k-2hashLength-2$
\end_inset

 bytes, with 
\begin_inset Formula $k$
\end_inset

 as the size of the modulus in bytes, and 
\begin_inset Formula $hashLength$
\end_inset

 as 
\begin_inset Formula $128$
\end_inset

 in our case.
 This introduces randomness at the cost of a smaller message space than
 unpadded or PKCS v1.5.
 
\end_layout

\begin_layout Standard
The library would be much more useful if it had functionality for importing
 existing RSA keys created in other applications.
 For instance, we should support implementing keys in the PKCS#8 format
 
\begin_inset CommandInset citation
LatexCommand cite
key "PKCS8"

\end_inset

.
 Future work should include implementing PKCS#1 v1.5 padding.
 RSA Security recommends RSAES-OAEP for new applications, but includes PKCS1-v1.5
 for compatibility.
 However, v1.5 is still heavily used.
 For instance, the OpenPGP standard supports only v1.5 padding 
\begin_inset CommandInset citation
LatexCommand cite
key "RFC4880"

\end_inset

.
 We've not implemented the signature schemes in PCKS#1 v2.1.
 This would also be an useful addition to our library.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
We have implemented AES, SHA, CBC and RSA in the D programming language.
 In order to make our library ready for practical use, some functionality
 is missing.
 These include signature schemes, loading existing keys, and a crypto-grade
 PRNG.
 We would of course have liked to cover more primitives, as well as high-level
 schemes, but encountered performance challenges along the way.
 We have learned that hardware-specific implementations and optimizations
 are extremely important in order to get high performance.
 Our results show that our semi-optimized solutions are generally quite
 fast, but still not as fast as the more common C implementations.
 In order to fairly judge the speed of the D language, we would have to
 implement the same optimizations in D.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "FIPS197"
key "FIPS197"

\end_inset

Federal Information Processing Standards Publication 197: Advanced Encryption
 Standard (AES)
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "Dlang.org"
key "Dlang"

\end_inset

Official homepage of the D programming language, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

dlang.org
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "Phobos"
key "Phobos"

\end_inset

D standard library (Phobos), 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/D-Programming-Language/phobos
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "Intel"
key "Intel"

\end_inset

Intel® Advanced Encryption Standard (AES) Instructions Set - Rev 3
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "SHS"
key "SHS"

\end_inset


\begin_inset Quotes erd
\end_inset

Secure Hash Standard (SHS)
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "OAEP"
key "OAEP"

\end_inset


\begin_inset Quotes eld
\end_inset

Optimal Asymmetric Encryption How to Encrypt with RSA
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://cseweb.ucsd.edu/users/mihir/papers/oae.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "PKCS1 v2.1"

\end_inset


\begin_inset Quotes eld
\end_inset

PKCS #1 v2.1: RSA Cryptography Standard
\begin_inset Quotes eld
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "PKCS8"

\end_inset


\begin_inset Quotes eld
\end_inset

Private-Key Information Syntax Specification Version 1.2
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://tools.ietf.org/html/rfc5208
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "RFC4880"

\end_inset


\begin_inset Quotes eld
\end_inset

RFC 4880: OpenPGP Message Format
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://tools.ietf.org/html/rfc4880#section-13.1
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "OpenSSL Rand Documentation"

\end_inset


\begin_inset Quotes eld
\end_inset

OpenSSL Rand Documentation
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.openssl.org/docs/crypto/rand.html
\end_layout

\end_inset

 
\end_layout

\end_body
\end_document
